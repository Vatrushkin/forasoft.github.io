---
layout: post
title:  "Методы отладки приложений на&nbsp;socket.io"
date:   2016-11-22 16:00:00 +0300
permalink: /debugging-socket.io/
tags: [socket.io, javascript, debug]
keywords: [socket.io, javascript, debug]
author: pabloid
---
Socket.io&nbsp;&mdash; популярная библиотека для организации передачи данных от&nbsp;браузера серверу и&nbsp;наоборот. Использовать ее&nbsp;достаточно просто, но&nbsp;на&nbsp;больших проектах возникает проблема отладки как сервера, так и&nbsp;клиента. 
 
Предположим мы&nbsp;делаем чат, в&nbsp;котором пользователи общаются между собой. Приложение состоит из&nbsp;браузерного клиента и&nbsp;сервера на&nbsp;node.js. Если приложение делает один человек, то&nbsp;проблем с&nbsp;отладкой скорее всего не&nbsp;возникнет: он&nbsp;откроет Chrome Web Tools и&nbsp;посмотрит, что и куда запрашивается. Но когда&nbsp;клиент и&nbsp;сервер делают разные люди, может получиться, что сервер уже готов, а&nbsp;клиент еще нет или&nbsp;наоборот.

 <!--more-->

Для примера возьмем [такую реализацию](https://github.com/Pabloader/socket-debug-example/blob/master/index.js).

Со стороны сервера у нас имеется 3 cобытия:

- *register*
- *login*
- *message*

Алгоритм действий:

1. *register*, передаем `login` и `password`. Данные передаются первым аргументом в объекте: `{login: ‘pavel’, password: ‘1234’}`. Вторым аргументом идет callback, который получит ошибку, если она есть. Callback соответствует принятому в node.js - первый параметр - ошибка, если есть, второй - ответ.
2. *login*, данные те же, что и у *register*. В callback передается `accessToken`, если ошибок нет.
3. *message* - `{token: '{accessToken}', message: '{text}'}`

Отвечать на&nbsp;пришедшее сообщение необязательно отправкой другого сообщения, можно передать последним аргументом callback и&nbsp;просто вызывать его как обычный callback в&nbsp;любой другой ситуации. Подробнее [об&nbsp;этом](http://socket.io/docs/#sending-and-getting-data-(acknowledgements)).

Входящее событие message содержит данные вида `{message: ‘<text>’, user: ‘<username>’}`

Рассмотрим, как отладить сервер, если у&nbsp;нас ещё не&nbsp;готов клиент.

### Встроенные логи socket.io

Сама библиотека предоставляет некоторые возможности для отладки. Включить их&nbsp;можно с&nbsp;помощью `localStorage.debug='*'` в&nbsp;браузере или запуская сервер с&nbsp;переменной окружения `DEBUG=*`. Используется библиотека [debug](https://github.com/visionmedia/debug), предоставляющая удобные логи, которые можно гибко настраивать, указывая параметры вместо `*` в выражениях выше.  

![](/assets/posts/debug-socket.io/image01.png)

В нашем случае такой способ сам по себе мы использовать не можем, поскольку нужен клиент, но его можно применять в совокупности с другими методами.

Во всех последующих примерах предполагается что сервер уже запущен с логированием, его адрес <http://localhost:8888/>.

### Chrome Dev Tools 
В&nbsp;первом методе предполагается написание нужного для проверки кода прямо в&nbsp;консоли браузера, со&nbsp;всеми подключениями к&nbsp;сокету, навешиванием событий и&nbsp;т.п.

Попробуем отправить сообщение, используя такой метод.
Для начала нужно найти страницу, где уже подключена библиотека socket.io, либо написать свою. Как вариант, зайти на&nbsp;сайт <http://socket.io/>.
 
Открываем консоль, создаем соединение: 
```js
var socket = io('http://localhost:8888');
```

В&nbsp;консоли сервера видим, что подключение состоялось: 

![](/assets/posts/debug-socket.io/image02.png)


Теперь можем регистрироваться, логиниться и&nbsp;пробовать отправить что-нибудь:
	
```js
socket.emit('register', {login: 'pavel', password: '1234'}, err => console.error(err));
socket.emit('login', {login: 'pavel', password: '1234'}, (err, token) => err ? console.error(err): window.token = token);
```

Сразу становится очевиден минус такого подхода: приходится писать все в&nbsp;одну строку, что катастрофически сказывается на&nbsp;читабельности. 
Допустим ошибок не&nbsp;возникло, тогда в&nbsp;переменной `window.token`  будет токен юзера, который нужен для отправки сообщений.

В&nbsp;консоли сервера видим, что сообщения пришли: 

![](/assets/posts/debug-socket.io/image00.png)

![](/assets/posts/debug-socket.io/image04.png)

И&nbsp;на&nbsp;`login` пришел ответ:

![](/assets/posts/debug-socket.io/image06.png)

Теперь подпишемся на&nbsp;событие `message`, чтобы получить сообщение: 

```js
socket.on('message', data => console.log(data));
```

Логика отправки сообщений проста&nbsp;&mdash; при получении события, сервер проверяет правильность токена, и&nbsp;если все хорошо, пересылает сообщение всем подключенным клиентам, включая того, кто его отправил. Может быть это не&nbsp;самое удачное решение, но&nbsp;для демонстрации сгодится.

Отправляем само сообщение:

```js
socket.emit('message', {message: 'test', token: window.token});
```

Сообщение пришло, сервер подставил имя автора дополнительно к&nbsp;тексту:

![](/assets/posts/debug-socket.io/image05.png)

Таким нехитрым образом можно проверять простую логику или наличие соединения. Но&nbsp;что-то более сложное сделать проблематично&nbsp;&mdash; приходится все записывать в&nbsp;одну строку, либо использовать `Shift+Enter` в&nbsp;консоли, чтобы сделать переход на&nbsp;новую, но&nbsp;об&nbsp;этом легко забыть и&nbsp;выполнить еще недописанный код.

### Отдельная HTML-страничка
Логичным продолжением написания кода в&nbsp;консоли будет вынесение его в&nbsp;отдельный файл. Это избавляет от&nbsp;необходимости каждый раз переписывать все команды заново, достаточно перезагрузить страницу. Результат работы можно выводить в&nbsp;ту&nbsp;же консоль, отображать в&nbsp;HTML, в&nbsp;крайнем случае показывать alert-ами. 

Делать мы&nbsp;будем то&nbsp;же самое, что и&nbsp;в&nbsp;прошлом примере. В&nbsp;итоге получим макет клиента. Для более сложных приложений можно разбить отдельные части по&nbsp;разным файлам, например отдельно авторизация, отдельно чат, отдельно звонки и&nbsp;т.п.

Внешне клиент выглядит примерно следующим образом:

![](/assets/posts/debug-socket.io/image07.png)

Здесь есть необходимые формы, а&nbsp;также поля с&nbsp;отладочной информацией. Ознакомиться с&nbsp;кодом можно&nbsp;[тут](https://github.com/Pabloader/socket-debug-example/blob/master/debug.html). 

По&nbsp;сравнению с&nbsp;предыдущим вариантом добавилась обработка ошибок и&nbsp;интерфейс.
При этом мы&nbsp;можем все так&nbsp;же открыть консоль и&nbsp;выполнить некоторый код там, если нам нужна интерактивность. Но&nbsp;отдельный файл можно поместить в&nbsp;репозиторий и&nbsp;им&nbsp;например могут воспользоваться тестировщики.
Часто таким образом делают всевозможные генераторы. Допустим нам нужно иметь в&nbsp;системе 100&nbsp;пользователей. Их, конечно&nbsp;же, можно зарегистрировать вручную, но&nbsp;это займет уйму времени. А&nbsp;если их&nbsp;надо не&nbsp;100, а&nbsp;1000? Или 10000? Тут на&nbsp;помощь приходит генератор. Для нашего случая создаем форму с&nbsp;параметрами: количество пользователей и&nbsp;пароль. И регистрируем пользователей: 

```js
for (var i=0; i < numUsers; i++) {
    socket.emit('register', {login: 'user' + i, password: password});
}
```

### Автоматизированные тесты
Улучшением предыдущего метода является написание тестов. В&nbsp;отличии от&nbsp;него, тесты могут (и&nbsp;должны) быть выполнены автоматически.
Для node.js существует socket.io клиент, установим его:

```bash
npm install --save socket.io-client
```

Установим нужные зависимости для тестов:

```bash
npm install --save-dev mocha
npm install --save-dev should
```

Создаем файл теста, подключаем необходимые модули: 

```js
var should = require('should');
var io = require('socket.io-client');
var randToken = require('rand-token');
````

Задаем параметры:

```js
var url = 'http://0.0.0.0:8888/';

var options = {
    transports: ['websocket'],
    'force new connection': true
};
```

Пишем пару тестов для примера. В&nbsp;реальном приложении их&nbsp;может быть значительно больше. 

```js
describe('Server', function () {
    it('should register new user and login', function (done) {
        var client = io.connect(url, options);
        client.on('connect', function () {
            var user = generateUser();
            client.emit('register', user, function (err) {
                should.not.exist(err);
                client.emit('login', user, function (err, token) {
                    should.not.exist(err);
                    should(token).be.ok();
                    done();
                });
            });
        });
        client.on('connect_error', function (e) {
            should.not.exist(e);
        });
    });
    it('should send and receive message', function (done) {
        var client = io.connect(url, options);
        var message = randToken.generate(128);
        client.on('connect', function () {
            var user = generateUser();
            client.emit('register', user, function (err) {
                should.not.exist(err);


                client.emit('login', user, function (err, token) {
                    should.not.exist(err);
                    should(token).be.ok();


                    client.on('message', function (data) {
                        should(data).have.properties('message', 'user');
                        if (data.user === user.login) {
                            should(data.message).be.equal(message);
                            done();
                        }
                    });
                    client.emit('message', {token: token, message: message}, function (err) {
                        should.not.exist(err);
                    });
                });
            });
        });
        client.on('connect_error', function (e) {
            should.not.exist(e);
        });
    });
});
```

Полностью файл теста располагается [тут](https://github.com/Pabloader/socket-debug-example/blob/master/index.test.js).
Для удобства, допишем в&nbsp;`package.json` команду тестирования: 

```
"scripts": {
    "test": "mocha index.test.js"
}
```

Запускаем: `npm test`

Если сервер запущен, то&nbsp;в&nbsp;консоли мы&nbsp;увидим:

![](/assets/posts/debug-socket.io/image04.png)

Тесты прошли успешно. Далее можно добавлять еще тестов, проверить на&nbsp;возникающие ошибки, например. 

Недостаток такого метода&nbsp;&mdash; нужно писать код тестов, расставлять проверки, но&nbsp;это компенсируется удобством дальнейшего использования. Также проблему представляет база данных. В&nbsp;более-менее сложном приложении без нее не&nbsp;обойтись, и&nbsp;для тестирования она нужна отдельная.


### Специальное приложение или веб-сайт
Часто возникает ситуация, когда нужно не&nbsp;комплексное тестирование, а&nbsp;отладка в&nbsp;реальном времени, интерактивно. В&nbsp;таком случае методы 2&nbsp;и&nbsp;3&nbsp;нам категорически не&nbsp;подходят, поскольку в&nbsp;них нужно учесть возможные ситуации заранее. Первый способ лучше в&nbsp;этом плане, но&nbsp;далек от&nbsp;идеала из-за необходимости писать много лишнего кода. Специальное приложение позволяет решить эту проблему&nbsp;&mdash; нам вообще не&nbsp;нужно писать код, мы&nbsp;отправили событие, посмотрели ответ, решили что делать, отправили второе событие и&nbsp;т.д. Тут клиентом выступаем мы&nbsp;сами, но&nbsp;нам нужен удобный транспорт для передачи событий. 


Таких приложений не&nbsp;так уж&nbsp;и&nbsp;много и&nbsp;они не&nbsp;блещут функциональностью:

- <http://scaret.in/socket.io-client/>
  - Возможно подключение к нескольким серверам одновременно
  - Чтобы получать сообщения, на событие нужно подписаться
  - Отправка только простых текстовых данных
- <https://github.com/socketio/socket.io/issues/2014>
  - Возможна отправка объектов, формат YAML
  - Не запоминает последние введенные данные

Как средство тестирования приложение&nbsp;&mdash; не&nbsp;лучший выбор, нужно постоянно помнить алгоритм, и&nbsp;не&nbsp;ошибаться при вводе. Оно больше подходит разработчику клиента, чтобы изучить API, посмотреть что откуда возвращается, какие приходят события и&nbsp;т.п.

### Выводы
Каждый метод хорош по-своему, никто не&nbsp;запрещает использовать все, либо какие-то комбинации из&nbsp;них. Если нужно регулярное тестирование&nbsp;&mdash; на&nbsp;помощь придут автоматизированные тесты. Необходима интерактивность&nbsp;&mdash; используем приложение. Нужно сгенерировать что-то&nbsp;&mdash; больше всего подойдет специально созданная HTML-страница.
